"use strict";
(self["webpackChunkhelloapp"] = self["webpackChunkhelloapp"] || []).push([["vendors-node_modules_vue-cal_dist_drag-and-drop_es_js"],{

/***/ "./node_modules/vue-cal/dist/drag-and-drop.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-cal/dist/drag-and-drop.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragAndDrop: () => (/* binding */ DragAndDrop)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
/**
  * vue-cal v4.10.0
  * (c) 2024 Antoni Andre <antoniandre.web@gmail.com>
  * @license MIT
  */
const holdOverTimeout = 800;
let changeViewTimeout = null;
let pressPrevOrNextInterval = null;
let viewBeforeDrag = { id: null, date: null };
let viewChanged = false;
let cancelViewChange = true;
let dragOverCell = { el: null, cell: null, timeout: null };
const dragging = {
  _eid: null,
  fromVueCal: null,
  toVueCal: null
};
const DragAndDrop = class {
  constructor(vuecal) {
    __publicField(this, "_vuecal");
    this._vuecal = vuecal;
  }
  /**
   * When click and drag an event the cursor can be anywhere in the event,
   * when dropping the event, we need to subtract the cursor position in the event.
   *
   * @param {Object} e The associated DOM event.
   */
  _getEventStart(e) {
    const { timeStep, timeCellHeight, timeFrom, utils } = this._vuecal;
    let { y } = utils.cell.getPosition(e);
    y -= e.dataTransfer.getData("cursor-grab-at") * 1;
    return Math.round(y * timeStep / parseInt(timeCellHeight) + timeFrom);
  }
  /**
   * On drop, update the event start and end date directly into the event.
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} event The event being dragged.
   * @param {Object} transferData The transfer data from the HTML5 dragging event.
   * @param {Date} cellDate The hovered cell starting date.
   */
  _updateEventStartEnd(e, event, transferData, cellDate) {
    const eventDuration = transferData.duration * 1 || event.endTimeMinutes - event.startTimeMinutes;
    let startTimeMinutes = Math.max(this._getEventStart(e), 0);
    if (this._vuecal.snapToTime) {
      const plusHalfSnapTime = startTimeMinutes + this._vuecal.snapToTime / 2;
      startTimeMinutes = plusHalfSnapTime - plusHalfSnapTime % this._vuecal.snapToTime;
    }
    event.startTimeMinutes = startTimeMinutes;
    event.start = new Date(new Date(cellDate).setMinutes(startTimeMinutes));
    event.endTimeMinutes = Math.min(startTimeMinutes + eventDuration, 24 * 60);
    event.end = new Date(new Date(cellDate).setMinutes(event.endTimeMinutes));
  }
  /**
   * On event drag start, only possible if editableEvent is true.
   * /!\ This is using the native HTML5 drag & drop, not supported on touch devices.
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} event The event being dragged.
   */
  eventDragStart(e, event) {
    if (e.target.nodeType === 3) return e.preventDefault();
    e.dataTransfer.dropEffect = "move";
    e.dataTransfer.setData("event", JSON.stringify(event));
    e.dataTransfer.setData("cursor-grab-at", e.offsetY);
    const { clickHoldAnEvent } = this._vuecal.domEvents;
    setTimeout(() => {
      clickHoldAnEvent._eid = null;
      clearTimeout(clickHoldAnEvent.timeoutId);
      event.deleting = false;
    }, 0);
    this._vuecal.domEvents.dragAnEvent._eid = event._eid;
    dragging._eid = event._eid;
    dragging.fromVueCal = this._vuecal._.uid;
    event.dragging = true;
    setTimeout(() => event.draggingStatic = true, 0);
    viewChanged = false;
    viewBeforeDrag = { id: this._vuecal.view.id, date: this._vuecal.view.startDate };
    cancelViewChange = true;
  }
  /**
   * On event drag end, when releasing the event.
   *
   * @param {Object} event The event being dragged.
   */
  eventDragEnd(event) {
    this._vuecal.domEvents.dragAnEvent._eid = null;
    dragging._eid = null;
    event.dragging = false;
    event.draggingStatic = false;
    const { fromVueCal, toVueCal } = dragging;
    if (toVueCal && fromVueCal !== toVueCal) this._vuecal.utils.event.deleteAnEvent(event);
    dragging.fromVueCal = null;
    dragging.toVueCal = null;
    if (viewChanged && cancelViewChange && viewBeforeDrag.id) this._vuecal.switchView(viewBeforeDrag.id, viewBeforeDrag.date, true);
  }
  /**
   * On cell/split enter with a dragging event.
   * Highlight the cell, and if on `years`, `year`, `month` view,
   * set a timer to go deeper on drag hold over this cell.
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} cell The cell component's $data.
   * @param {Date} cellDate The hovered cell starting date.
   */
  cellDragEnter(e, cell, cellDate) {
    const target = e.currentTarget;
    if (e.currentTarget.contains(e.relatedTarget)) return;
    if (target === dragOverCell.el || !target.className.includes("vuecal__cell-content")) return false;
    if (dragOverCell.el) dragOverCell.cell.highlighted = false;
    dragOverCell = { el: target, cell, timeout: clearTimeout(dragOverCell.timeout) };
    cell.highlighted = true;
    if (["years", "year", "month"].includes(this._vuecal.view.id)) {
      dragOverCell.timeout = setTimeout(() => this._vuecal.switchToNarrowerView(cellDate), 2e3);
    }
  }
  /**
   * On cell/split drag over, highlight the cell being hovered,
   * Useful when starting to drag event on the same cell/split it's in.
   * Warning: This is fired repeatedly as long as you stay over this cell/split.
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} cell The cell component's $data.
   * @param {Date} cellDate The hovered cell starting date.
   * @param {Number|String} split The optional split being hovered if any.
   */
  cellDragOver(e, cell, cellDate, split) {
    e.preventDefault();
    cell.highlighted = true;
    if (split || split === 0) cell.highlightedSplit = split;
  }
  /**
   * When event drag leaves a cell/split.
   * Remove the cell/split highlighted state.
   * Warning: cell dragleave event happens AFTER another cell dragenter!
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} cell The cell component's $data.
   */
  cellDragLeave(e, cell) {
    e.preventDefault();
    if (e.currentTarget.contains(e.relatedTarget)) return;
    cell.highlightedSplit = false;
    if (dragOverCell.cell === cell) {
      clearTimeout(dragOverCell.timeout);
      dragOverCell = { el: null, cell: null, timeout: null };
      cell.highlighted = false;
    }
  }
  /**
   * On successful event drop into a cell/split.
   * Change the event start and end time and remove the event dragging state
   * and cell/split highlighted state.
   *
   * @param {Object} e The associated DOM event.
   * @param {Object} cell The cell component's $data.
   * @param {Date} cellDate The hovered cell starting date.
   * @param {Number|String} split The optional split being dropped into, if any.
   */
  cellDragDrop(e, cell, cellDate, split) {
    e.preventDefault();
    clearTimeout(dragOverCell.timeout);
    dragOverCell = { el: null, cell: null, timeout: null };
    const transferData = JSON.parse(e.dataTransfer.getData("event") || "{}");
    let event, addToView;
    if (dragging.fromVueCal !== this._vuecal._.uid) {
      const { _eid, start, end, duration, ...cleanTransferData } = transferData;
      event = this._vuecal.utils.event.createAnEvent(cellDate, duration, { ...cleanTransferData, split });
    } else {
      event = this._vuecal.view.events.find((evt) => evt._eid === dragging._eid);
      if (!event) {
        event = this._vuecal.mutableEvents.find((evt) => evt._eid === dragging._eid);
        addToView = !!event;
      }
      if (!event) {
        const duration = transferData.endTimeMinutes - transferData.startTimeMinutes;
        const { start, end, ...cleanTransferData } = transferData;
        event = this._vuecal.utils.event.createAnEvent(cellDate, duration, { ...cleanTransferData, split });
      }
    }
    const { start: oldDate, split: oldSplit } = event;
    this._updateEventStartEnd(e, event, transferData, cellDate);
    if (addToView) this._vuecal.addEventsToView([event]);
    event.dragging = false;
    if (split || split === 0) event.split = split;
    cell.highlighted = false;
    cell.highlightedSplit = null;
    cancelViewChange = false;
    dragging.toVueCal = this._vuecal._.uid;
    const params = {
      event: this._vuecal.cleanupEvent(event),
      oldDate,
      newDate: event.start,
      ...(split || split === 0) && { oldSplit, newSplit: split },
      originalEvent: this._vuecal.cleanupEvent(transferData),
      external: !dragging.fromVueCal
      // If external event, not coming from any Vue Cal.
    };
    this._vuecal.$emit("event-drop", params);
    this._vuecal.$emit("event-change", { event: params.event, originalEvent: params.originalEvent });
    setTimeout(() => {
      if (dragging._eid) this.eventDragEnd(event);
    }, 300);
  }
  /**
   * On drag enter on a view button or on today, prev & next buttons.
   * Sets a highlighted state on the hovered button, and go to requested view.
   *
   * @param {Object} e The associated DOM event.
   * @param {String} id The id of the header element being hovered. One of:
   *                    previous, next, today, years, year, month, week, day.
   * @param {Object} headerData The header component's $data.
   */
  viewSelectorDragEnter(e, id, headerData) {
    if (e.currentTarget.contains(e.relatedTarget)) return;
    headerData.highlightedControl = id;
    clearTimeout(changeViewTimeout);
    changeViewTimeout = setTimeout(() => {
      if (["previous", "next"].includes(id)) {
        this._vuecal[id]();
        clearInterval(pressPrevOrNextInterval);
        pressPrevOrNextInterval = setInterval(this._vuecal[id], holdOverTimeout);
      } else if (id === "today") {
        clearInterval(pressPrevOrNextInterval);
        let viewId;
        if (this._vuecal.view.id.includes("year")) {
          viewId = this._vuecal.enabledViews.filter((view) => !view.includes("year"))[0];
        }
        this._vuecal.switchView(viewId || this._vuecal.view.id, new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)), true);
      } else this._vuecal.switchView(id, null, true);
      viewChanged = true;
    }, holdOverTimeout);
  }
  /**
   * On drag leave on a view button or on today, prev & next buttons.
   * Removes the highlighted state on the hovered button, and cancel the timer to
   * go to the requested view.
   *
   * @param {Object} e The associated DOM event.
   * @param {String} id The id of the header element being hovered. One of:
   *                    previous, next, today, years, year, month, week, day.
   * @param {Object} headerData The header component's $data.
   */
  viewSelectorDragLeave(e, id, headerData) {
    if (e.currentTarget.contains(e.relatedTarget)) return;
    if (headerData.highlightedControl === id) {
      headerData.highlightedControl = null;
      if (changeViewTimeout) changeViewTimeout = clearTimeout(changeViewTimeout);
      if (pressPrevOrNextInterval) pressPrevOrNextInterval = clearInterval(pressPrevOrNextInterval);
    }
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdnVlLWNhbF9kaXN0X2RyYWctYW5kLWRyb3BfZXNfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQsVUFBVSxJQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSxjQUFjLG1EQUFtRDtBQUNqRSwyRUFBMkUsNkJBQTZCO0FBQ3hHLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQsNkVBQTZFLDZCQUE2QjtBQUMxRztBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUEwRDtBQUNuRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsb2FwcC8uL25vZGVfbW9kdWxlcy92dWUtY2FsL2Rpc3QvZHJhZy1hbmQtZHJvcC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuLyoqXG4gICogdnVlLWNhbCB2NC4xMC4wXG4gICogKGMpIDIwMjQgQW50b25pIEFuZHJlIDxhbnRvbmlhbmRyZS53ZWJAZ21haWwuY29tPlxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuY29uc3QgaG9sZE92ZXJUaW1lb3V0ID0gODAwO1xubGV0IGNoYW5nZVZpZXdUaW1lb3V0ID0gbnVsbDtcbmxldCBwcmVzc1ByZXZPck5leHRJbnRlcnZhbCA9IG51bGw7XG5sZXQgdmlld0JlZm9yZURyYWcgPSB7IGlkOiBudWxsLCBkYXRlOiBudWxsIH07XG5sZXQgdmlld0NoYW5nZWQgPSBmYWxzZTtcbmxldCBjYW5jZWxWaWV3Q2hhbmdlID0gdHJ1ZTtcbmxldCBkcmFnT3ZlckNlbGwgPSB7IGVsOiBudWxsLCBjZWxsOiBudWxsLCB0aW1lb3V0OiBudWxsIH07XG5jb25zdCBkcmFnZ2luZyA9IHtcbiAgX2VpZDogbnVsbCxcbiAgZnJvbVZ1ZUNhbDogbnVsbCxcbiAgdG9WdWVDYWw6IG51bGxcbn07XG5jb25zdCBEcmFnQW5kRHJvcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodnVlY2FsKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl92dWVjYWxcIik7XG4gICAgdGhpcy5fdnVlY2FsID0gdnVlY2FsO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIGNsaWNrIGFuZCBkcmFnIGFuIGV2ZW50IHRoZSBjdXJzb3IgY2FuIGJlIGFueXdoZXJlIGluIHRoZSBldmVudCxcbiAgICogd2hlbiBkcm9wcGluZyB0aGUgZXZlbnQsIHdlIG5lZWQgdG8gc3VidHJhY3QgdGhlIGN1cnNvciBwb3NpdGlvbiBpbiB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICovXG4gIF9nZXRFdmVudFN0YXJ0KGUpIHtcbiAgICBjb25zdCB7IHRpbWVTdGVwLCB0aW1lQ2VsbEhlaWdodCwgdGltZUZyb20sIHV0aWxzIH0gPSB0aGlzLl92dWVjYWw7XG4gICAgbGV0IHsgeSB9ID0gdXRpbHMuY2VsbC5nZXRQb3NpdGlvbihlKTtcbiAgICB5IC09IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJjdXJzb3ItZ3JhYi1hdFwiKSAqIDE7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeSAqIHRpbWVTdGVwIC8gcGFyc2VJbnQodGltZUNlbGxIZWlnaHQpICsgdGltZUZyb20pO1xuICB9XG4gIC8qKlxuICAgKiBPbiBkcm9wLCB1cGRhdGUgdGhlIGV2ZW50IHN0YXJ0IGFuZCBlbmQgZGF0ZSBkaXJlY3RseSBpbnRvIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IGJlaW5nIGRyYWdnZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2ZlckRhdGEgVGhlIHRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgSFRNTDUgZHJhZ2dpbmcgZXZlbnQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gY2VsbERhdGUgVGhlIGhvdmVyZWQgY2VsbCBzdGFydGluZyBkYXRlLlxuICAgKi9cbiAgX3VwZGF0ZUV2ZW50U3RhcnRFbmQoZSwgZXZlbnQsIHRyYW5zZmVyRGF0YSwgY2VsbERhdGUpIHtcbiAgICBjb25zdCBldmVudER1cmF0aW9uID0gdHJhbnNmZXJEYXRhLmR1cmF0aW9uICogMSB8fCBldmVudC5lbmRUaW1lTWludXRlcyAtIGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXM7XG4gICAgbGV0IHN0YXJ0VGltZU1pbnV0ZXMgPSBNYXRoLm1heCh0aGlzLl9nZXRFdmVudFN0YXJ0KGUpLCAwKTtcbiAgICBpZiAodGhpcy5fdnVlY2FsLnNuYXBUb1RpbWUpIHtcbiAgICAgIGNvbnN0IHBsdXNIYWxmU25hcFRpbWUgPSBzdGFydFRpbWVNaW51dGVzICsgdGhpcy5fdnVlY2FsLnNuYXBUb1RpbWUgLyAyO1xuICAgICAgc3RhcnRUaW1lTWludXRlcyA9IHBsdXNIYWxmU25hcFRpbWUgLSBwbHVzSGFsZlNuYXBUaW1lICUgdGhpcy5fdnVlY2FsLnNuYXBUb1RpbWU7XG4gICAgfVxuICAgIGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXMgPSBzdGFydFRpbWVNaW51dGVzO1xuICAgIGV2ZW50LnN0YXJ0ID0gbmV3IERhdGUobmV3IERhdGUoY2VsbERhdGUpLnNldE1pbnV0ZXMoc3RhcnRUaW1lTWludXRlcykpO1xuICAgIGV2ZW50LmVuZFRpbWVNaW51dGVzID0gTWF0aC5taW4oc3RhcnRUaW1lTWludXRlcyArIGV2ZW50RHVyYXRpb24sIDI0ICogNjApO1xuICAgIGV2ZW50LmVuZCA9IG5ldyBEYXRlKG5ldyBEYXRlKGNlbGxEYXRlKS5zZXRNaW51dGVzKGV2ZW50LmVuZFRpbWVNaW51dGVzKSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGV2ZW50IGRyYWcgc3RhcnQsIG9ubHkgcG9zc2libGUgaWYgZWRpdGFibGVFdmVudCBpcyB0cnVlLlxuICAgKiAvIVxcIFRoaXMgaXMgdXNpbmcgdGhlIG5hdGl2ZSBIVE1MNSBkcmFnICYgZHJvcCwgbm90IHN1cHBvcnRlZCBvbiB0b3VjaCBkZXZpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgYmVpbmcgZHJhZ2dlZC5cbiAgICovXG4gIGV2ZW50RHJhZ1N0YXJ0KGUsIGV2ZW50KSB7XG4gICAgaWYgKGUudGFyZ2V0Lm5vZGVUeXBlID09PSAzKSByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIjtcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiZXZlbnRcIiwgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiY3Vyc29yLWdyYWItYXRcIiwgZS5vZmZzZXRZKTtcbiAgICBjb25zdCB7IGNsaWNrSG9sZEFuRXZlbnQgfSA9IHRoaXMuX3Z1ZWNhbC5kb21FdmVudHM7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGlja0hvbGRBbkV2ZW50Ll9laWQgPSBudWxsO1xuICAgICAgY2xlYXJUaW1lb3V0KGNsaWNrSG9sZEFuRXZlbnQudGltZW91dElkKTtcbiAgICAgIGV2ZW50LmRlbGV0aW5nID0gZmFsc2U7XG4gICAgfSwgMCk7XG4gICAgdGhpcy5fdnVlY2FsLmRvbUV2ZW50cy5kcmFnQW5FdmVudC5fZWlkID0gZXZlbnQuX2VpZDtcbiAgICBkcmFnZ2luZy5fZWlkID0gZXZlbnQuX2VpZDtcbiAgICBkcmFnZ2luZy5mcm9tVnVlQ2FsID0gdGhpcy5fdnVlY2FsLl8udWlkO1xuICAgIGV2ZW50LmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LmRyYWdnaW5nU3RhdGljID0gdHJ1ZSwgMCk7XG4gICAgdmlld0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2aWV3QmVmb3JlRHJhZyA9IHsgaWQ6IHRoaXMuX3Z1ZWNhbC52aWV3LmlkLCBkYXRlOiB0aGlzLl92dWVjYWwudmlldy5zdGFydERhdGUgfTtcbiAgICBjYW5jZWxWaWV3Q2hhbmdlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogT24gZXZlbnQgZHJhZyBlbmQsIHdoZW4gcmVsZWFzaW5nIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkcmFnZ2VkLlxuICAgKi9cbiAgZXZlbnREcmFnRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5fdnVlY2FsLmRvbUV2ZW50cy5kcmFnQW5FdmVudC5fZWlkID0gbnVsbDtcbiAgICBkcmFnZ2luZy5fZWlkID0gbnVsbDtcbiAgICBldmVudC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGV2ZW50LmRyYWdnaW5nU3RhdGljID0gZmFsc2U7XG4gICAgY29uc3QgeyBmcm9tVnVlQ2FsLCB0b1Z1ZUNhbCB9ID0gZHJhZ2dpbmc7XG4gICAgaWYgKHRvVnVlQ2FsICYmIGZyb21WdWVDYWwgIT09IHRvVnVlQ2FsKSB0aGlzLl92dWVjYWwudXRpbHMuZXZlbnQuZGVsZXRlQW5FdmVudChldmVudCk7XG4gICAgZHJhZ2dpbmcuZnJvbVZ1ZUNhbCA9IG51bGw7XG4gICAgZHJhZ2dpbmcudG9WdWVDYWwgPSBudWxsO1xuICAgIGlmICh2aWV3Q2hhbmdlZCAmJiBjYW5jZWxWaWV3Q2hhbmdlICYmIHZpZXdCZWZvcmVEcmFnLmlkKSB0aGlzLl92dWVjYWwuc3dpdGNoVmlldyh2aWV3QmVmb3JlRHJhZy5pZCwgdmlld0JlZm9yZURyYWcuZGF0ZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGNlbGwvc3BsaXQgZW50ZXIgd2l0aCBhIGRyYWdnaW5nIGV2ZW50LlxuICAgKiBIaWdobGlnaHQgdGhlIGNlbGwsIGFuZCBpZiBvbiBgeWVhcnNgLCBgeWVhcmAsIGBtb250aGAgdmlldyxcbiAgICogc2V0IGEgdGltZXIgdG8gZ28gZGVlcGVyIG9uIGRyYWcgaG9sZCBvdmVyIHRoaXMgY2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2VsbCBUaGUgY2VsbCBjb21wb25lbnQncyAkZGF0YS5cbiAgICogQHBhcmFtIHtEYXRlfSBjZWxsRGF0ZSBUaGUgaG92ZXJlZCBjZWxsIHN0YXJ0aW5nIGRhdGUuXG4gICAqL1xuICBjZWxsRHJhZ0VudGVyKGUsIGNlbGwsIGNlbGxEYXRlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICAgIGlmICh0YXJnZXQgPT09IGRyYWdPdmVyQ2VsbC5lbCB8fCAhdGFyZ2V0LmNsYXNzTmFtZS5pbmNsdWRlcyhcInZ1ZWNhbF9fY2VsbC1jb250ZW50XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRyYWdPdmVyQ2VsbC5lbCkgZHJhZ092ZXJDZWxsLmNlbGwuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICBkcmFnT3ZlckNlbGwgPSB7IGVsOiB0YXJnZXQsIGNlbGwsIHRpbWVvdXQ6IGNsZWFyVGltZW91dChkcmFnT3ZlckNlbGwudGltZW91dCkgfTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICBpZiAoW1wieWVhcnNcIiwgXCJ5ZWFyXCIsIFwibW9udGhcIl0uaW5jbHVkZXModGhpcy5fdnVlY2FsLnZpZXcuaWQpKSB7XG4gICAgICBkcmFnT3ZlckNlbGwudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fdnVlY2FsLnN3aXRjaFRvTmFycm93ZXJWaWV3KGNlbGxEYXRlKSwgMmUzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9uIGNlbGwvc3BsaXQgZHJhZyBvdmVyLCBoaWdobGlnaHQgdGhlIGNlbGwgYmVpbmcgaG92ZXJlZCxcbiAgICogVXNlZnVsIHdoZW4gc3RhcnRpbmcgdG8gZHJhZyBldmVudCBvbiB0aGUgc2FtZSBjZWxsL3NwbGl0IGl0J3MgaW4uXG4gICAqIFdhcm5pbmc6IFRoaXMgaXMgZmlyZWQgcmVwZWF0ZWRseSBhcyBsb25nIGFzIHlvdSBzdGF5IG92ZXIgdGhpcyBjZWxsL3NwbGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsIFRoZSBjZWxsIGNvbXBvbmVudCdzICRkYXRhLlxuICAgKiBAcGFyYW0ge0RhdGV9IGNlbGxEYXRlIFRoZSBob3ZlcmVkIGNlbGwgc3RhcnRpbmcgZGF0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzcGxpdCBUaGUgb3B0aW9uYWwgc3BsaXQgYmVpbmcgaG92ZXJlZCBpZiBhbnkuXG4gICAqL1xuICBjZWxsRHJhZ092ZXIoZSwgY2VsbCwgY2VsbERhdGUsIHNwbGl0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgIGlmIChzcGxpdCB8fCBzcGxpdCA9PT0gMCkgY2VsbC5oaWdobGlnaHRlZFNwbGl0ID0gc3BsaXQ7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gZXZlbnQgZHJhZyBsZWF2ZXMgYSBjZWxsL3NwbGl0LlxuICAgKiBSZW1vdmUgdGhlIGNlbGwvc3BsaXQgaGlnaGxpZ2h0ZWQgc3RhdGUuXG4gICAqIFdhcm5pbmc6IGNlbGwgZHJhZ2xlYXZlIGV2ZW50IGhhcHBlbnMgQUZURVIgYW5vdGhlciBjZWxsIGRyYWdlbnRlciFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2VsbCBUaGUgY2VsbCBjb21wb25lbnQncyAkZGF0YS5cbiAgICovXG4gIGNlbGxEcmFnTGVhdmUoZSwgY2VsbCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICBjZWxsLmhpZ2hsaWdodGVkU3BsaXQgPSBmYWxzZTtcbiAgICBpZiAoZHJhZ092ZXJDZWxsLmNlbGwgPT09IGNlbGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChkcmFnT3ZlckNlbGwudGltZW91dCk7XG4gICAgICBkcmFnT3ZlckNlbGwgPSB7IGVsOiBudWxsLCBjZWxsOiBudWxsLCB0aW1lb3V0OiBudWxsIH07XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbiBzdWNjZXNzZnVsIGV2ZW50IGRyb3AgaW50byBhIGNlbGwvc3BsaXQuXG4gICAqIENoYW5nZSB0aGUgZXZlbnQgc3RhcnQgYW5kIGVuZCB0aW1lIGFuZCByZW1vdmUgdGhlIGV2ZW50IGRyYWdnaW5nIHN0YXRlXG4gICAqIGFuZCBjZWxsL3NwbGl0IGhpZ2hsaWdodGVkIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsIFRoZSBjZWxsIGNvbXBvbmVudCdzICRkYXRhLlxuICAgKiBAcGFyYW0ge0RhdGV9IGNlbGxEYXRlIFRoZSBob3ZlcmVkIGNlbGwgc3RhcnRpbmcgZGF0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzcGxpdCBUaGUgb3B0aW9uYWwgc3BsaXQgYmVpbmcgZHJvcHBlZCBpbnRvLCBpZiBhbnkuXG4gICAqL1xuICBjZWxsRHJhZ0Ryb3AoZSwgY2VsbCwgY2VsbERhdGUsIHNwbGl0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNsZWFyVGltZW91dChkcmFnT3ZlckNlbGwudGltZW91dCk7XG4gICAgZHJhZ092ZXJDZWxsID0geyBlbDogbnVsbCwgY2VsbDogbnVsbCwgdGltZW91dDogbnVsbCB9O1xuICAgIGNvbnN0IHRyYW5zZmVyRGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImV2ZW50XCIpIHx8IFwie31cIik7XG4gICAgbGV0IGV2ZW50LCBhZGRUb1ZpZXc7XG4gICAgaWYgKGRyYWdnaW5nLmZyb21WdWVDYWwgIT09IHRoaXMuX3Z1ZWNhbC5fLnVpZCkge1xuICAgICAgY29uc3QgeyBfZWlkLCBzdGFydCwgZW5kLCBkdXJhdGlvbiwgLi4uY2xlYW5UcmFuc2ZlckRhdGEgfSA9IHRyYW5zZmVyRGF0YTtcbiAgICAgIGV2ZW50ID0gdGhpcy5fdnVlY2FsLnV0aWxzLmV2ZW50LmNyZWF0ZUFuRXZlbnQoY2VsbERhdGUsIGR1cmF0aW9uLCB7IC4uLmNsZWFuVHJhbnNmZXJEYXRhLCBzcGxpdCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSB0aGlzLl92dWVjYWwudmlldy5ldmVudHMuZmluZCgoZXZ0KSA9PiBldnQuX2VpZCA9PT0gZHJhZ2dpbmcuX2VpZCk7XG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIGV2ZW50ID0gdGhpcy5fdnVlY2FsLm11dGFibGVFdmVudHMuZmluZCgoZXZ0KSA9PiBldnQuX2VpZCA9PT0gZHJhZ2dpbmcuX2VpZCk7XG4gICAgICAgIGFkZFRvVmlldyA9ICEhZXZlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdHJhbnNmZXJEYXRhLmVuZFRpbWVNaW51dGVzIC0gdHJhbnNmZXJEYXRhLnN0YXJ0VGltZU1pbnV0ZXM7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgLi4uY2xlYW5UcmFuc2ZlckRhdGEgfSA9IHRyYW5zZmVyRGF0YTtcbiAgICAgICAgZXZlbnQgPSB0aGlzLl92dWVjYWwudXRpbHMuZXZlbnQuY3JlYXRlQW5FdmVudChjZWxsRGF0ZSwgZHVyYXRpb24sIHsgLi4uY2xlYW5UcmFuc2ZlckRhdGEsIHNwbGl0IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHN0YXJ0OiBvbGREYXRlLCBzcGxpdDogb2xkU3BsaXQgfSA9IGV2ZW50O1xuICAgIHRoaXMuX3VwZGF0ZUV2ZW50U3RhcnRFbmQoZSwgZXZlbnQsIHRyYW5zZmVyRGF0YSwgY2VsbERhdGUpO1xuICAgIGlmIChhZGRUb1ZpZXcpIHRoaXMuX3Z1ZWNhbC5hZGRFdmVudHNUb1ZpZXcoW2V2ZW50XSk7XG4gICAgZXZlbnQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBpZiAoc3BsaXQgfHwgc3BsaXQgPT09IDApIGV2ZW50LnNwbGl0ID0gc3BsaXQ7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWRTcGxpdCA9IG51bGw7XG4gICAgY2FuY2VsVmlld0NoYW5nZSA9IGZhbHNlO1xuICAgIGRyYWdnaW5nLnRvVnVlQ2FsID0gdGhpcy5fdnVlY2FsLl8udWlkO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGV2ZW50OiB0aGlzLl92dWVjYWwuY2xlYW51cEV2ZW50KGV2ZW50KSxcbiAgICAgIG9sZERhdGUsXG4gICAgICBuZXdEYXRlOiBldmVudC5zdGFydCxcbiAgICAgIC4uLihzcGxpdCB8fCBzcGxpdCA9PT0gMCkgJiYgeyBvbGRTcGxpdCwgbmV3U3BsaXQ6IHNwbGl0IH0sXG4gICAgICBvcmlnaW5hbEV2ZW50OiB0aGlzLl92dWVjYWwuY2xlYW51cEV2ZW50KHRyYW5zZmVyRGF0YSksXG4gICAgICBleHRlcm5hbDogIWRyYWdnaW5nLmZyb21WdWVDYWxcbiAgICAgIC8vIElmIGV4dGVybmFsIGV2ZW50LCBub3QgY29taW5nIGZyb20gYW55IFZ1ZSBDYWwuXG4gICAgfTtcbiAgICB0aGlzLl92dWVjYWwuJGVtaXQoXCJldmVudC1kcm9wXCIsIHBhcmFtcyk7XG4gICAgdGhpcy5fdnVlY2FsLiRlbWl0KFwiZXZlbnQtY2hhbmdlXCIsIHsgZXZlbnQ6IHBhcmFtcy5ldmVudCwgb3JpZ2luYWxFdmVudDogcGFyYW1zLm9yaWdpbmFsRXZlbnQgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoZHJhZ2dpbmcuX2VpZCkgdGhpcy5ldmVudERyYWdFbmQoZXZlbnQpO1xuICAgIH0sIDMwMCk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGRyYWcgZW50ZXIgb24gYSB2aWV3IGJ1dHRvbiBvciBvbiB0b2RheSwgcHJldiAmIG5leHQgYnV0dG9ucy5cbiAgICogU2V0cyBhIGhpZ2hsaWdodGVkIHN0YXRlIG9uIHRoZSBob3ZlcmVkIGJ1dHRvbiwgYW5kIGdvIHRvIHJlcXVlc3RlZCB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGhlYWRlciBlbGVtZW50IGJlaW5nIGhvdmVyZWQuIE9uZSBvZjpcbiAgICogICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLCBuZXh0LCB0b2RheSwgeWVhcnMsIHllYXIsIG1vbnRoLCB3ZWVrLCBkYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJEYXRhIFRoZSBoZWFkZXIgY29tcG9uZW50J3MgJGRhdGEuXG4gICAqL1xuICB2aWV3U2VsZWN0b3JEcmFnRW50ZXIoZSwgaWQsIGhlYWRlckRhdGEpIHtcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICBoZWFkZXJEYXRhLmhpZ2hsaWdodGVkQ29udHJvbCA9IGlkO1xuICAgIGNsZWFyVGltZW91dChjaGFuZ2VWaWV3VGltZW91dCk7XG4gICAgY2hhbmdlVmlld1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChbXCJwcmV2aW91c1wiLCBcIm5leHRcIl0uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHRoaXMuX3Z1ZWNhbFtpZF0oKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwcmVzc1ByZXZPck5leHRJbnRlcnZhbCk7XG4gICAgICAgIHByZXNzUHJldk9yTmV4dEludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fdnVlY2FsW2lkXSwgaG9sZE92ZXJUaW1lb3V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaWQgPT09IFwidG9kYXlcIikge1xuICAgICAgICBjbGVhckludGVydmFsKHByZXNzUHJldk9yTmV4dEludGVydmFsKTtcbiAgICAgICAgbGV0IHZpZXdJZDtcbiAgICAgICAgaWYgKHRoaXMuX3Z1ZWNhbC52aWV3LmlkLmluY2x1ZGVzKFwieWVhclwiKSkge1xuICAgICAgICAgIHZpZXdJZCA9IHRoaXMuX3Z1ZWNhbC5lbmFibGVkVmlld3MuZmlsdGVyKCh2aWV3KSA9PiAhdmlldy5pbmNsdWRlcyhcInllYXJcIikpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Z1ZWNhbC5zd2l0Y2hWaWV3KHZpZXdJZCB8fCB0aGlzLl92dWVjYWwudmlldy5pZCwgbmV3IERhdGUoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKSksIHRydWUpO1xuICAgICAgfSBlbHNlIHRoaXMuX3Z1ZWNhbC5zd2l0Y2hWaWV3KGlkLCBudWxsLCB0cnVlKTtcbiAgICAgIHZpZXdDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9LCBob2xkT3ZlclRpbWVvdXQpO1xuICB9XG4gIC8qKlxuICAgKiBPbiBkcmFnIGxlYXZlIG9uIGEgdmlldyBidXR0b24gb3Igb24gdG9kYXksIHByZXYgJiBuZXh0IGJ1dHRvbnMuXG4gICAqIFJlbW92ZXMgdGhlIGhpZ2hsaWdodGVkIHN0YXRlIG9uIHRoZSBob3ZlcmVkIGJ1dHRvbiwgYW5kIGNhbmNlbCB0aGUgdGltZXIgdG9cbiAgICogZ28gdG8gdGhlIHJlcXVlc3RlZCB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGhlYWRlciBlbGVtZW50IGJlaW5nIGhvdmVyZWQuIE9uZSBvZjpcbiAgICogICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLCBuZXh0LCB0b2RheSwgeWVhcnMsIHllYXIsIG1vbnRoLCB3ZWVrLCBkYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJEYXRhIFRoZSBoZWFkZXIgY29tcG9uZW50J3MgJGRhdGEuXG4gICAqL1xuICB2aWV3U2VsZWN0b3JEcmFnTGVhdmUoZSwgaWQsIGhlYWRlckRhdGEpIHtcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICBpZiAoaGVhZGVyRGF0YS5oaWdobGlnaHRlZENvbnRyb2wgPT09IGlkKSB7XG4gICAgICBoZWFkZXJEYXRhLmhpZ2hsaWdodGVkQ29udHJvbCA9IG51bGw7XG4gICAgICBpZiAoY2hhbmdlVmlld1RpbWVvdXQpIGNoYW5nZVZpZXdUaW1lb3V0ID0gY2xlYXJUaW1lb3V0KGNoYW5nZVZpZXdUaW1lb3V0KTtcbiAgICAgIGlmIChwcmVzc1ByZXZPck5leHRJbnRlcnZhbCkgcHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHByZXNzUHJldk9yTmV4dEludGVydmFsKTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBEcmFnQW5kRHJvcFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==